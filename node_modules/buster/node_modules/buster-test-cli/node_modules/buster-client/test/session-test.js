var buster = require("buster");
var createServerFor = require("./test-helper").createServerFor;
var bSession = require("../lib/session");
var faye = require("faye");
var bayeuxEmitter = require("buster-bayeux-emitter");

buster.testCase("buster.session", {
    "createFromHttpResponse": {
        setUp: function () {
            this.response = buster.extend(buster.create(buster.eventEmitter), {
                headers: {
                    connection: "close",
                    "transfer-encoding": "chunked",
                    location: "/sessions/1"
                },
                statusCode: 201,
                setEncoding: this.spy()
            });

            this.respond = function (response) {
                response = response || JSON.stringify({
                    rootPath: "/sessions/1",
                    resourcesPath: "/sessions/ae255322-2c8f-4f0e-9719-a662cafa1c34/resources",
                    bayeuxClientPath: "/sessions/messaging",
                    id: 1,
                    slaves: []
                });

                process.nextTick(function () {
                    this.response.emit("data", response);
                    this.response.emit("end");
                }.bind(this));

                return this.response;
            };

            this.stub(bayeuxEmitter, "create").returns({
                connect: this.stub().yields()
            });
        },

        "resolves promise with session object": function (done) {
            var response, instance = {};
            instance.connect = this.stub().yields(instance);
            this.stub(bSession, "create").returns(instance);

            bSession.createFromHttpResponse(this.response, {
                host: "localhost",
                port: 1111
            }).then(done(function (session) {
                assert.calledWith(response.setEncoding, "utf8");
                assert.equals(bSession.create.args[0][1], {
                    rootPath: "/sessions/1",
                    bayeuxClientPath: "/sessions/messaging",
                    resourcesPath: "/sessions/ae255322-2c8f-4f0e-9719-a662cafa1c34/resources",
                    id: 1,
                    host: "localhost",
                    port: 1111,
                    slaves: []
                });

                assert.same(instance, session);
            }));

            response = this.respond();
        },

        "rejects promise with JSON parse error": function (done) {
            this.spy(bSession, "create");

            bSession.createFromHttpResponse(this.response).then(
                function () {},
                done(function (err, session) {
                    refute.defined(session);
                    refute.isNull(err);
                    refute.called(bSession.create);
                })
            );

            this.respond("{");
        },

        "rejects promise when server fails": function (done) {
            this.spy(bSession, "create");
            this.response.statusCode = 500;

            bSession.createFromHttpResponse(this.response).then(
                function () {},
                done(function (err, session) {
                    refute.defined(session);
                    refute.isNull(err);
                    refute.called(bSession.create);
                })
            );

            this.respond("Something went wrong");
        },

        "connects messaging client": function (done) {
            var opt = { host: "localhost", port: 1111 };

            var create = bSession.createFromHttpResponse(this.response, opt);
            create.then(done(function (sess) {
                refute.isNull(sess.bayeuxClient);
                assert.equals(sess.bayeuxClient.endpoint,
                              "http://localhost:1111/sessions/messaging");
            }));

            this.respond();
        },

        "does not connect messaging when no messaging path": function (done) {
            var response = this.response;
            bSession.createFromHttpResponse(response).then(done(function (s) {
                assert.isNull(s.bayeuxClient);
            }));

            response = this.respond(JSON.stringify({
                rootPath: "/sessions/1"
            }));
        }
    },

    "create": {
        "sets rootPath, host, port and slaves": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0",
                host: "buster.local",
                port: 1110,
                slaves: [{ id: "4d1eb0d1-8ffc-4e22-a163-e7a96cad73b3" }]
            });

            assert.match(session, {
                rootPath: "/sessions/0",
                host: "buster.local",
                port: 1110,
                slaves: [{ id: "4d1eb0d1-8ffc-4e22-a163-e7a96cad73b3" }]
            });
        },

        "defaults slaves to empty array": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0",
                host: "buster.local",
                port: 1110
            });

            assert.equals(session.slaves, []);
        },

        "uses default host": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0",
                port: 1110
            });

            assert.equals(session.host, "localhost");
        },

        "uses default port": function () {
            var session = bSession.create(null, { rootPath: "/sessions/0" });

            assert.equals(session.port, 1111);
        }
    },

    "close": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
        },

        tearDown: function () {
            this.server.close();
        },

        "makes DELETE request to session": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/1",
                host: "localhost",
                port: 7777
            });

            session.close().then(done(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "DELETE",
                    url: "/sessions/1"
                });
            }.bind(this)));
        },

        "uses session properties in DELETE request": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            session.close().then(done(function () {
                assert.match(this.requests[0], { url: "/sessions/2" });
            }.bind(this)));
        },

        "rejects promise with error on bad connection": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                host: "bogus"
            });

            var regexp = new RegExp("(Domain name not found)|" +
                                    "(Could not contact DNS servers)|" +
                                    "(getaddrinfo)");

            session.close().then(function () {}, done(function (err) {
                refute.isNull(err);
                assert.match(err.message, regexp);
            }.bind(this)));
        },

        "rejects promise if server responds with error": function (done) {
            this.responseCode = 500;

            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            session.close().then(function () {}, done(function (err) {
                refute.isNull(err);
                assert.match(err.message, /500/);
            }.bind(this)));
        },

        "disconnects messaging client": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            var disconnect = this.spy();
            session.messagingClient = { disconnect: disconnect };

            session.close().then(done(function () {
                assert.calledOnce(disconnect);
            }.bind(this)));
        },

        "kills session": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            var http = require("http");
            this.spy(http, "request");

            session.close();

            process.nextTick(done(function () {
                assert.calledOnce(http.request);
            }));
        }
    },

    "without messaging": {
        setUp: function () {
            this.session = bSession.create(null, {});
        },

        "on fails": function () {
            try {
                this.session.on("msg", function () {});
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        },

        "emit fails if session has no messaging client": function () {
            try {
                this.session.emit("msg");
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        },

        "onMessage fails": function () {
            try {
                this.session.onMessage(function () {});
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        }
    },

    "messaging": {
        setUp: function (done) {
            this.path = "/sessions/1/messages";
            this.url = "http://localhost:7777" + this.path;
            var mc = new faye.NodeAdapter({ mount: this.path });

            this.server = require("http").createServer(function (req, res) {
                res.writeHead(200);
                res.end();
            });

            mc.attach(this.server);
            this.server.listen(7777, done);
            this.bayeuxClient = new faye.Client(this.url);
            var self = this;

            this.connectedClient = function (then) {
                var session = bSession.create(self.bayeuxClient, {
                    port: 7777,
                    id: 1,
                    managed: self.managed
                });

                session.connect(function () { then(session); });
                return session;
            };
        },

        tearDown: function (done) {
            this.server.on("close", done);
            this.session.close().then(function () {
                this.server.close();
            }.bind(this));
        },

        "sends message with messaging client": function (done) {
            this.session = this.connectedClient(function (session) {
                session.on("/msg", done(function (msg) {
                    assert.equals(msg.data, 42);
                }));

                session.emit("/msg", 42);
            });
        },

        "subscribes to any event": function (done) {
            this.session = this.connectedClient(function (session) {
                session.onMessage(done(function (msg) {
                    assert.equals(msg.data, 42);
                    assert.equals(msg.topic, "msg");
                }));

                session.emit("msg", 42);
            });
        },

        "publishes /session-owner for managed session": function (done) {
            var publish = this.stub(this.bayeuxClient, "publish");
            this.managed = true;

            this.session = this.connectedClient(done(function (session) {
                assert.calledOnceWith(publish, "/session-owner");
            }));
        },

        "does not publish owner for unmanaged session": function (done) {
            var publish = this.stub(this.bayeuxClient, "publish");
            this.managed = false;

            this.session = this.connectedClient(done(function (session) {
                refute.called(publish);
            }));
        }
    }
});
