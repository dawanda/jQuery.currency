var createServerFor = require("./test-helper").createServerFor;
var buster = require("buster");
var bClient = require("../lib/buster-client").client;
var bSession = require("../lib/buster-client").session;
var http = require("http");
var rs = require("buster-resources");
var when = require("when");

buster.testCase("buster.client", {
    "create": {
        "returns client instance": function () {
            var client = bClient.create(9876, "10.0.0.1", "/buster");

            assert(bClient.isPrototypeOf(client));
            assert.equals(client.host, "10.0.0.1");
            assert.equals(client.port, 9876);
            assert.equals(client.path, "/buster");
        },

        "defaults path to /": function () {
            var client = bClient.create(1111);

            assert.equals(client.path, "/");
        },

        "defaults host to localhost": function () {
            var client = bClient.create(1111);

            assert.equals(client.host, "localhost");
        },

        "defaults port to 1111": function () {
            var client = bClient.create();

            assert.equals(client.port, 1111);
        }
    },

    "getCachedResources": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
            this.client = bClient.create(7777);
        },

        tearDown: function () {
            this.server.close();
        },

        "GETs /resources": function (done) {
            this.client.getCachedResources().then(done(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "GET",
                    url: "/resources"
                });
            }.bind(this)));
        },

        "rejects promise if server is unreachable": function (done) {
            var req = buster.eventEmitter.create();
            req.end = function () { return req; };
            this.stub(http, "request").returns(req);

            this.client.getCachedResources().then(
                function () {},
                done(function (err) {
                    refute.isNull(err);
                    assert.match(err.message, "Oops!");
                }.bind(this))
            );

            req.emit("error", new Error("Oops!"));
        },

        "rejects if server does not recognize cache requests": function (done) {
            this.responseCode = 404;

            this.client.getCachedResources().then(
                function () {},
                done(function (err) {
                    refute.isNull(err);
                    assert.match(err.message, "Is this server");
                    assert.match(err.message, "(localhost:7777)");
                    assert.match(err.message, "buster-capture-server");
                }.bind(this))
            );
        },

        "rejects if server returns invalid cache data": function (done) {
            this.responseCode = 200;
            this.responseText = "<html>";

            this.client.getCachedResources().then(
                function () {},
                done(function (err) {
                    refute.isNull(err);
                    assert.match(err.message, "Is this server");
                }.bind(this))
            );
        },

        "GETs contextPath/resources": function (done) {
            this.client.path = "/buster";

            this.client.getCachedResources().then(done(function () {
                assert.match(this.requests[0], { url: "/buster/resources" });
            }.bind(this)));
        },

        "yields list of resources and etags": function (done) {
            this.responseText = JSON.stringify({
                "/some/file.js": ["0d44ea2"],
                "/some/stylesheet.css": ["034948f"],
                "/some/text.txt": ["1da82b4"]
            });

            this.client.getCachedResources().then(done(function (cacheable) {
                assert.equals(cacheable, {
                    "/some/file.js": ["0d44ea2"],
                    "/some/stylesheet.css": ["034948f"],
                    "/some/text.txt": ["1da82b4"]
                });
            }.bind(this)));
        },

        "yields empty object if no response body": function (done) {
            this.client.getCachedResources().then(done(function (cacheable) {
                assert.equals(cacheable, {});
            }.bind(this)));
        },

        "rejects promise if malformed response body": function (done) {
            this.responseText = "{";

            this.client.getCachedResources().then(
                function () {},
                done(function (err) {
                    refute.isNull(err);
                }.bind(this))
            );
        },

        "caches result of GET": function (done) {
            this.responseText = JSON.stringify({ "/some/file.js": ["0d44ea"] });

            this.client.getCachedResources().then(function () {
                this.client.getCachedResources().then(done(function (rs) {
                    assert.equals(this.requests.length, 1);
                    assert.equals(rs, { "/some/file.js": ["0d44ea"] });
                }.bind(this)));
            }.bind(this));
        }
    },

    "createSession": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
            this.client = bClient.create(7777);
            this.session = {};
            this.promise = when(this.session);
            this.stub(bSession, "createFromHttpResponse").returns(this.promise);

            this.cache = {};
            this.stub(bClient, "getCachedResources").returns(when(this.cache));
            this.resourceSet = rs.resourceSet.create();
        },

        tearDown: function () {
            this.server.close();
        },

        "POSTs to /sessions": function (done) {
            this.client.createSession({
                resourceSet: this.resourceSet
            }).then(done(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "POST",
                    headers: { host: "localhost" },
                    url: "/sessions"
                });
            }.bind(this)));
        },

        "rejects promise if HTTP connection fails": function (done) {
            var req = buster.eventEmitter.create();
            req.write = req.end = function () { return req; };
            this.stub(http, "request").returns(req);
            var client = bClient.create(7777, "localhost", "/buster");

            client.createSession({ resourceSet: this.resourceSet }).then(
                function () {},
                done(function (err) {
                    refute.isNull(err);
                    assert.match(err.message, "Oops!");
                }.bind(this))
            );

            req.emit("error", new Error("Oops!"));
        },

        "rejects promise if server rejects session": function (done) {
            var d = when.defer();
            d.resolver.reject({ message: "Server rejected session" });
            bSession.createFromHttpResponse.returns(d.promise);
            var options = { resourceSet: rs.resourceSet.create() };

            this.client.createSession(options).then(
                function () {},
                done(function (err) {
                    assert.defined(err);
                }.bind(this))
            );
        },

        "encodes session data in POST body": function (done) {
            var resources = rs.resourceSet.create();
            resources.addResources([
                { path: "/js/buster.js", content: "alert('Hello world');" },
                { path: "/css/style.css", content: "body { color: red; }" }]);
            resources.loadPath.append("/js/buster.js");
            var options = { resourceSet: resources, joinable: true };

            this.client.createSession(options).then(done(function () {
                var req = this.requests[0];
                var rs = JSON.parse(req.body).resourceSet;
                assert.equals(req.headers["content-type"], "application/json");
                assert.equals(rs.loadPath, ["/js/buster.js"]);
                assert.match(rs.resources[0], {
                    path: "/js/buster.js",
                    content: "alert('Hello world');"
                });
                assert.match(rs.resources[1], {
                    path: "/css/style.css",
                    content: "body { color: red; }"
                });
            }.bind(this)));
        },

        "rejects returned promise if session config is bad": function (done) {
            var resources = rs.resourceSet.create();
            resources.addResource({
                path: "/uh-oh",
                content: function () { throw new Error("Oops"); }
            });

            this.client.createSession({ resourceSet: resources }).then(
                function () {},
                done(function (err) {
                    assert.defined(err);
                    assert.equals(err.message, "Bad session config: Oops");
                }.bind(this))
            );
        },

        "resolves promise with session object when ready": function (done) {
            var options = { resourceSet: rs.resourceSet.create() };

            this.client.createSession(options).then(done(function (session) {
                assert.same(session, this.session);
            }.bind(this)));
        },

        "passes host and port to session": function (done) {
            var options = { resourceSet: rs.resourceSet.create() };

            this.client.createSession(options).then(done(function (session) {
                assert.match(bSession.createFromHttpResponse.args[0][1], {
                    host: "localhost",
                    port: 7777
                });
            }));
        },

        "passes managed to new session": function (done) {
            var options = {
                resourceSet: rs.resourceSet.create(),
                managed: true
            };

            this.client.createSession(options).then(done(function (session) {
                assert.match(bSession.createFromHttpResponse.args[0][1], {
                    managed: true
                });
            }));
        },

        "uses cached resources": function (done) {
            this.cache["/file1.js"] = ["1234"];
            var options = { resourceSet: rs.resourceSet.create() };

            options.resourceSet.addResources([
                { path: "/file1.js", content: "alert();", etag: "1234" },
                { path: "/file2.js", content: "prompt();", etag: "2345" }
            ]);

            this.client.createSession(options).then(done(function (session) {
                var rs = JSON.parse(this.requests[0].body).resourceSet;
                assert.same(rs.resources[0].content, "");
                refute.same(rs.resources[1].content, "");
            }.bind(this)));
        },

        "does not use cached resources if configured not to": function (done) {
            this.client.cacheResources = false;
            this.cache["/file1.js"] = ["1234"];
            var options = { resourceSet: rs.resourceSet.create() };

            options.resourceSet.addResources([
                { path: "/file1.js", content: "alert();", etag: "1234" },
                { path: "/file2.js", content: "prompt();", etag: "2345" }
            ]);

            this.client.createSession(options).then(done(function (session) {
                var rs = JSON.parse(this.requests[0].body).resourceSet;
                refute.same(rs.resources[0].content, "");
            }.bind(this)));
        },

        "uses staticResourcePath": function (done) {
            this.cache["/file1.js"] = ["1234"];
            var options = {
                resourceSet: rs.resourceSet.create(),
                staticResourcePath: true
            };

            this.client.createSession(options).then(done(function (session) {
                assert(JSON.parse(this.requests[0].body).staticResourcePath);
            }.bind(this)));
        },

        "rejects if unable to get cached resources": function (done) {
            var fail = when.defer();
            fail.resolver.reject(new Error("Oh"));
            bClient.getCachedResources.returns(fail.promise);
            var options = { resourceSet: rs.resourceSet.create() };

            this.client.createSession(options).then(
                function () {},
                done(function (err) {
                    assert.defined(err);
                    assert.match(err.message, "Oh");
                })
            );
        },

        "rejects if aborted": function (done) {
            var cached = when.defer();
            bClient.getCachedResources.returns(cached.promise);
            var options = { resourceSet: rs.resourceSet.create() };
            var promise = this.client.createSession(options);
            this.client.abort();

            promise.then(
                function () {},
                done(function (err) {
                    assert.defined(err);
                    assert.match(err.name, "AbortedError");
                })
            );

            cached.resolver.resolve({});
        }
    }
});
