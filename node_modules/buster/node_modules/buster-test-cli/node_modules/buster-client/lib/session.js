var http = require("http");
var buster = require("buster-core");
var responseBody = require("./util").responseBody;
var faye = require("buster-faye");
var bayeuxEmitter = require("buster-bayeux-emitter");
var when = require("when");

function isSuccess(res) {
    return res.statusCode >= 200 && res.statusCode < 300;
}

function requireMessagingClient(session) {
    if (!session.messagingClient) {
        throw new TypeError("Session has no messaging client");
    }
}

function messagingClient(options) {
    var path = options.bayeuxClientPath;
    if (!path) { return null; }
    var url = "http://" + options.host + ":" + options.port + path;
    return new faye.Client(url);
}

module.exports = {
    create: function (bayeuxClient, opt) {
        return buster.extend(Object.create(this), {
            slaves: opt.slaves || [],
            rootPath: opt.rootPath,
            host: opt.host || "localhost",
            port: opt.port || 1111,
            bayeuxClient: bayeuxClient,
            resourcesPath: opt.resourcesPath,
            managed: opt.managed
        });
    },

    connect: function (callback) {
        if (this.messagingClient || !this.bayeuxClient) { return callback(); }
        this.messagingClient = bayeuxEmitter.create(this.bayeuxClient);

        this.messagingClient.connect(function () {
            if (this.managed) { this.bayeuxClient.publish("/session-owner"); }
            if (typeof callback === "function") { callback(); }
        }.bind(this));
    },

    createFromHttpResponse: function (res, opt) {
        var options, session, d = when.defer();

        responseBody(res, function (body) {
            if (!isSuccess(res)) { return d.resolver.reject({message: body}); }
            try {
                options = buster.extend(JSON.parse(body), opt);
            } catch (e) {
                return d.resolver.reject(e);
            }
            session = this.create(messagingClient(options), options);
            session.connect(function () { d.resolver.resolve(session); });
        }.bind(this));

        return d.promise;
    },

    on: function (event, callback) {
        requireMessagingClient(this);
        this.messagingClient.on(event, callback);
    },

    emit: function (event, data) {
        requireMessagingClient(this);
        this.messagingClient.emit(event, data);
    },

    onMessage: function (callback) {
        requireMessagingClient(this);
        this.messagingClient.onMessage(callback);
    },

    close: function () {
        if (this.messagingClient) {
            this.messagingClient.disconnect();
        }
        var d = when.defer();
        var reqData = {
            method: "DELETE",
            host: this.host,
            port: this.port,
            path: this.rootPath
        };
        var req = http.request(reqData, function (res) {
            if (res.statusCode === 200) {
                d.resolver.resolve();
            } else {
                d.resolver.reject(new Error("Session close failed, " +
                                         res.statusCode));
            }
        });
        req.end();
        req.on("error", function (err) {
            try {
                d.resolver.reject(err);
            } catch (e) { /* One error is enough */ }
        });
        return d.promise;
    }
};
