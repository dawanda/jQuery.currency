var http = require("http");
var path = require("path");
var responseBody = require("./util").responseBody;
var B = require("buster-core");
var bSession = require("./session");
var when = require("when");

function requestSessionCreation(client, options, callback) {
    var httpOptions = client.httpOptions("POST", "sessions");
    var req = http.request(httpOptions, function (res) {
        bSession.createFromHttpResponse(res, {
            host: client.host,
            port: client.port,
            managed: !!options.managed
        }).then(function (session) {
            callback(null, session);
        }, callback);
    });

    req.on("error", callback);
    req.write(JSON.stringify(options));
    req.end();
}

function serverError(res, opt) {
    return new Error("Server responded to cache lookup with " +
                     res.statusCode + ", expected 200\n" +
                     "Is this server (" + opt.host + ":" + opt.port +
                     ") a buster-capture-server instance?");
}

function jsonError(e, opt) {
    return new Error("Server responded to cache lookup with " +
                     "invalid response data. Is this server (" +
                     opt.host + ":" + opt.port +
                     ") a buster-capture-server instance?\n" +
                     "Original error was " + e.message);
}

function prepareResources(client, resourceSet, callback) {
    var serialize = function (cached) {
        resourceSet.serialize(cached).then(
            B.partial(callback, null),
            function (err) {
                err.message = "Bad session config: " + err.message;
                callback(err);
            }
        );
    };
    if (client.cacheResources) {
        client.getCachedResources().then(serialize, callback);
    } else {
        serialize();
    }
}

function abort(client) {
    delete client.aborted;
    return {
        name: "AbortedError",
        message: "Session creation aborted"
    };
}

module.exports = {
    cacheResources: true,

    create: function (port, host, path) {
        return B.extend(Object.create(this), {
            port: port || 1111,
            host: host || "localhost",
            path: path || "/"
        });
    },

    abort: function () {
        this.aborted = true;
    },

    getCachedResources: function () {
        if (this.cachedResources) {
            return when(this.cachedResources);
        }
        var d = when.defer();
        var self = this;
        var opt = this.httpOptions("GET", "resources");
        var req = http.request(opt, function (res) {
            if (res.statusCode !== 200) {
                return d.resolver.reject(serverError(res, opt));
            }
            responseBody(res, function (body) {
                try {
                    self.cachedResources = (body && JSON.parse(body)) || {};
                    d.resolver.resolve(self.cachedResources);
                } catch (e) {
                    d.resolver.reject(jsonError(e, opt));
                }
            });
        });
        req.on("error", B.bind(d.resolver, "reject"));
        req.end();
        return d.promise;
    },

    createSession: function (configuration) {
        var d = when.defer();
        prepareResources(this, configuration.resourceSet, function (err, set) {
            if (err) { return d.resolver.reject(err); }
            if (this.aborted) { return d.resolver.reject(abort(this)); }
            var options = B.extend({}, configuration, {
                resourceSet: set
            });
            requestSessionCreation(this, options, function (err, session) {
                if (err) { return d.resolver.reject(err); }
                d.resolver.resolve(session);
            });
        }.bind(this));
        return d.promise;
    },

    httpOptions: function (method, rpath) {
        return {
            method: method,
            host: this.host,
            port: this.port,
            path: path.join(this.path, rpath),
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
    }
};
